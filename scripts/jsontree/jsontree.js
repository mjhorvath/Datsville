// Caption: JSON model tree generator
// Authors: Michael Horvath
// Version: 1.0.3
// Created: 2021/04/20
// Updated: 2021/04/24
// 
// This program generates a space-deliminated hierarchical list of models. It 
// takes as input a JSON file generated by mpd2json.
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

var fso;
var InputFileObject;
var OutputFileObject;
var arrayOne = [];
var outText = "";
var partCount = 0;
var modelCount = 0;
var outMode = 0;
var usageText = 
'Invalid usage.\n\n' +
'Example:\n' +
'\tcscript jsontree.js [input path] [-p|-m|-b]\n\n' +
'\t[input path] must point to a JSON file.\n' +
'\t[-p] parts only.\n' +
'\t[-s] sub-models only.\n' +
'\t[-b] both parts and sub-models.\n';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
if (!String.prototype.repeat)
{
	String.prototype.repeat = function(count)
	{
		'use strict';
		if (this == null)
		{
			throw new TypeError('can\'t convert ' + this + ' to object');
		}

		var str = '' + this;
		// To convert string to integer.
		count = +count;
		// Check NaN
		if (count != count)
		{
			count = 0;
		}

		if (count < 0)
		{
			throw new RangeError('repeat count must be non-negative');
		}

		if (count == Infinity)
		{
			throw new RangeError('repeat count must be less than infinity');
		}

		count = Math.floor(count);
		if (str.length == 0 || count == 0)
		{
			return '';
		}

		// Ensuring count is a 31-bit integer allows us to heavily optimize the
		// main part. But anyway, most current (August 2014) browsers can't handle
		// strings 1 << 28 chars or longer, so:
		if (str.length * count >= 1 << 28)
		{
			throw new RangeError('repeat count must not overflow maximum string size');
		}

		var maxCount = str.length * count;
		count = Math.floor(Math.log(count) / Math.log(2));
		while (count)
		{
			str += str;
			count--;
		}
		str += str.substring(0, maxCount - str.length);
		return str;
	}
}

// only continue if the script is run via Windows Scripting Host
if (typeof(WScript) != 'undefined')
{
	var progArgs = WScript.Arguments;
	var extensionA = /\.[jJ][sS][oO][nN]$/;
	var failCode = 0;	// needs to always be a power of 2
	if (progArgs.length != 2)
	{
		failCode += 1;
	}
	if (!extensionA.test(progArgs(0)))
	{
		failCode += 2;
	}
	if (progArgs(1) == '-b')
	{
		outMode = 0;
	}
	else if (progArgs(1) == '-p')
	{
		outMode = 1;
	}
	else if (progArgs(1) == '-m')
	{
		outMode = 2;
	}
	else
	{
		failCode += 4;
	}
	if (failCode == 0)
	{
		ProcessFile(progArgs(0));
	}
	else
	{
		WScript.Echo(usageText + '\nFailure code: ' + failCode);
	}
}

function ProcessFile(inFilePath)
{
	var startDate = new Date();
	WScript.Echo('Processing file: ' + inFilePath);
	fso = new ActiveXObject('Scripting.FileSystemObject');

	// read the input and store its contents as a string
	WScript.Echo('Reading input.');
	InputFileObject = fso.OpenTextFile(inFilePath, 1);
	var inputCodeString = InputFileObject.ReadAll();
	InputFileObject.Close();
	arrayOne = eval('(' + inputCodeString + ')');

	// get output file ready
	WScript.Echo('Prepping output.');
	var outFilePath = inFilePath + '.tree.txt';
	OutputFileObject = fso.OpenTextFile(outFilePath, 2, 1, 0);

	// process the model
	WScript.Echo('Walking the tree.');
	var iModel = arrayOne[0];
	var iFile = iModel.fileName;
	var iSubs = iModel.subFiles;
	WriteItem(iFile);
	modelCount += 1;
	WalkTree(iSubs, 1);

	// finishing up
	WScript.Echo('Finishing up.');
	OutputFileObject.Close();
	WScript.Echo(modelCount + ' models.');
	WScript.Echo(partCount + ' parts.');
	WScript.Echo((modelCount + partCount) + ' objects.');
	var endDate = new Date();
	WScript.Echo(((endDate - startDate)/1000) + ' seconds.');
}

function WalkTree(inSubFiles, indentLevel)
{
	for (var k in inSubFiles)
	{
		var kModel = inSubFiles[k];
		var kFile = kModel.subFileName;
		var kString = '  '.repeat(indentLevel) + kFile;
		var outSubFiles = [];
		var isSubModel = false;
		for (var i in arrayOne)
		{
			var iModel = arrayOne[i];
			var iFile = iModel.fileName;
			if (kFile.toLowerCase() == iFile.toLowerCase())
			{
				outSubFiles = iModel.subFiles;
				isSubModel = true;
				break;
			}
		}
		if (isSubModel == true)
		{
			if ((outMode == 2) || (outMode == 0)) {WriteItem(kString);}
			modelCount += 1;
			WalkTree(outSubFiles, indentLevel+1);
		}
		else
		{
			if ((outMode == 1) || (outMode == 0)) {WriteItem(kString);}
			partCount += 1;
		}
	}
}

function WriteItem(inString)
{
	WScript.Echo(inString);
	OutputFileObject.WriteLine(inString);
}
