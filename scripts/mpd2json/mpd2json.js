// Caption: LDraw MPD to JSON converter
// Authors: Michael Horvath
// Version: 0.4.0
// Created: 2020/02/20
// Updated: 2021/04/24
// 
// This program reads an XMPD or MPD model and ouputs a JSON representation of 
// the model. It ignores all line types except line type 1 and a few recognized 
// meta commands. You should not expect the conversion process to be reversible 
// for these reasons. The program also will NOT search the file system looking 
// for sub-model files. This is why only the XMPD and MPD model formats are 
// currently supported. XMPD models are generated by MPDCenter by Michael 
// Heidemann. You will need to use an external utility to pretty-print the JSON 
// file. There are several JSON pretty-printers available online. The output 
// file name is the same as the input file name plus the ".json" extension.
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

var fso;
var wshShell;
var usageText =
'Invalid usage.\n\n'+
'syntax example: cscript mpd2json.js [input path]\n\n'+
'[input path] must be an XMPD or MPD file.\n\n';
var objectsArray = [];
var objectsCount = 0;

// only continue if the script is run via Windows Scripting Host
if (typeof(WScript) != 'undefined')
{
	var progArgs = WScript.Arguments;
	var inputFilePath = progArgs(0);
	var extensionA = /\.[xX][mM][pP][dD]$/;
	var extensionB = /\.[mM][pP][dD]$/;
	var extensionC = /\.[lL][dD][rR]$/;		// not properly supported yet
	var extensionD = /\.[dD][aA][tT]$/;		// not properly supported yet
	var failCode = 0;
	if (progArgs.length != 1)
	{
		failCode += 1;
	}
	else if (!extensionA.test(inputFilePath) && !extensionB.test(inputFilePath))
	{
		failCode += 2;
	}
	if (failCode == 0)
	{
		WScript.Echo('Reading and processing input.');
		var startDate = new Date();
		fso = new ActiveXObject('Scripting.FileSystemObject');
		// to do: need to run this recursively for every sub-model that is not already listed in the JSON input
		// to do: need to try to load models from disk whenever a model can't be found in the JSON input
		ProcessFile(inputFilePath);

		WScript.Echo('Writing output.');
		var outputFileString = ObjToSource(objectsArray);
		var outputFilePath = inputFilePath + '.json';
		var outputFileObject = fso.OpenTextFile(outputFilePath, 2, 1, 0);
		outputFileObject.Write(outputFileString);
		outputFileObject.Close();

		WScript.Echo('Finishing up.');
		WScript.Echo(objectsCount + ' objects processed.');
		var endDate = new Date();
		WScript.Echo(((endDate - startDate)/1000) + ' seconds.');
	}
	else
	{
		WScript.Echo(usageText + '\nFailure code: ' + failCode);
	}
}

function ProcessFile(thisPath)
{
	WScript.Echo('Processing file: ' + thisPath);
	var inputFileObject = fso.OpenTextFile(thisPath, 1);
	var subFilesCount = 0;
	var linesCount = 0;
	var tempObject;
	var hasDescription = false;
	while (!inputFileObject.AtEndOfStream)
	{
		var inputString = inputFileObject.ReadLine();
		WScript.Echo(inputString);
		var stringArray = inputString.split(/\s/);

		// meta tags and comments
		if (stringArray[0] == '0')
		{
			if ((inputString.match(/0\s+FILE/)) || (linesCount == 0))
			{
				tempObject = {}
				objectsArray[objectsCount++] = tempObject;
				tempObject.fileName = stringArray[2];
				tempObject.subFiles = [];
				subFilesCount = 0;
				hasDescription = false;
			}
			// not sure yet if apostraphes and quotes need to be escaped further
			else if (inputString.match(/^0\s+Name\:\s+(.*)$/))
			{
				tempObject.name = inputString.replace(/^0\s+Name\:\s+(.*)$/,'$1');
			}
			else if (inputString.match(/^0\s+Author\:\s+(.*)$/))
			{
				tempObject.author = inputString.replace(/^0\s+Author\:\s+(.*)$/,'$1');
			}
			else if (inputString.match(/^0\s+\!LICENSE\s+(.*)$/))
			{
				tempObject.license = inputString.replace(/^0\s+\!LICENSE\s+(.*)$/,'$1');
			}
			// multiple possible "type" meta tags should be case-insensitive
			else if (inputString.match(/^0\s+\!LDRAW_ORG\s+(.*)$/))
			{
				tempObject.type = inputString.replace(/^0\s+\!LDRAW_ORG\s+(.*)$/,'$1');
			}
			else if (inputString.match(/^0\s+LDRAW_ORG\s+(.*)$/))
			{
				tempObject.type = inputString.replace(/^0\s+LDRAW_ORG\s+(.*)$/,'$1');
			}
			else if (inputString.match(/^0\s+Official\s+LCAD\s+(.*)$/))
			{
				tempObject.type = inputString.replace(/^0\s+Official\s+LCAD\s+(.*)$/,'$1');
			}
			else if (inputString.match(/^0\s+Unofficial\s+(.*)$/))
			{
				tempObject.type = inputString.replace(/^0\s+Unofficial\s+(.*)$/,'$1');
			}
			else if (inputString.match(/^0\s+Un\-official\s+(.*)$/))
			{
				tempObject.type = inputString.replace(/^0\s+Un\-official\s+(.*)$/,'$1');
			}
			else if (hasDescription == false)
			{
				tempObject.description = inputString.replace(/^0\s+(.*)$/,'$1');
				hasDescription = true;
			}
			// these are MLCAD tags
			else if (inputString.match(/^0\s+ROTATION CENTER\s+(.*)$/))
			{
				tempObject.rotationCenter = [parseFloat(stringArray[3]),parseFloat(stringArray[4]),parseFloat(stringArray[5]),parseFloat(stringArray[6]),stringArray[7]];
			}
			else if (inputString.match(/^0\s+ROTATION CONFIG\s+(.*)$/))
			{
				tempObject.rotationConfig = [parseFloat(stringArray[3]),parseFloat(stringArray[4])];
			}
		}
		// sub-models and parts
		else if (stringArray[0] == '1')
		{
			// 1 <colour> x y z a b c d e f g h i <file>
			var tempSubFile		= {}
			tempSubFile.color	=   parseFloat(stringArray[ 1]);
			tempSubFile.x		=   parseFloat(stringArray[ 2]);
			tempSubFile.y		=   parseFloat(stringArray[ 3]);
			tempSubFile.z		=   parseFloat(stringArray[ 4]);
			tempSubFile.a		=   parseFloat(stringArray[ 5]);
			tempSubFile.b		=   parseFloat(stringArray[ 6]);
			tempSubFile.c		=   parseFloat(stringArray[ 7]);
			tempSubFile.d		=   parseFloat(stringArray[ 8]);
			tempSubFile.e		=   parseFloat(stringArray[ 9]);
			tempSubFile.f		=   parseFloat(stringArray[10]);
			tempSubFile.g		=   parseFloat(stringArray[11]);
			tempSubFile.h		=   parseFloat(stringArray[12]);
			tempSubFile.i		=   parseFloat(stringArray[13]);
			tempSubFile.subFileName	=   stringArray[14];		// string!
			tempObject.subFiles[subFilesCount++] = tempSubFile;
		}
		// need to handle other line types here
		else
		{
		}
		linesCount += 1;
	}
	inputFileObject.Close();
}

// https://stackoverflow.com/questions/957537/how-can-i-display-a-javascript-object
// cc by-sa 4.0
// with modifications, no indentation sadly
// would prefer it if quotes were added to string indices only if the string indices contained whitespace characters
function ObjToSource(o)
{
	if (!o) {return 'null';}
	var k = '';
	var na = typeof(o.length) == 'undefined';
	var str = '';
	for (var p in o)
	{
		if (na) {k = '"' + p + '":';}
		if (typeof o[p] == 'string') {str += k + '"' + o[p].replace(/\\/g,'\\\\').replace(/\"/g,'\\"') + '",';}
		else if (typeof o[p] == 'object') {str += k + ObjToSource(o[p]) + ',';}
		else {str += k + o[p] + ',';}
	}
	if (na) {return '{' + str.slice(0, -1) + '}';}
	else {return '[' + str.slice(0, -1) + ']';}
}
