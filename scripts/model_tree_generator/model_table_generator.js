// Caption: LDraw model tree generator
// Authors: Michael Horvath
// Version: 1.0.1
// Created: 2021/04/20
// Updated: 2021/04/21
// 
// This program generates a space-deliminated hierarchical list of models. It 
// takes as input a JSON file generated by mpd2json.
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

var fso;
var InputFileObject;
var OutputFileObject;
var arrayOne = [];
var outText = "";
var partCount = 0;
var modelCount = 0;
var objectCount = 0;
var outMode = 0;
var usageText = 
'Invalid usage.\n\n' +
'Example:\n' +
'\tcscript model_table_generator.js [input path] [-p|-m|-b]\n' +
'\t[input path] must point to a JSON file.\n' +
'\t[-p] parts only.\n' +
'\t[-s] sub-models only.\n' +
'\t[-b] both parts and sub-models.\n';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    'use strict';
    if (this == null)
      throw new TypeError('can\'t convert ' + this + ' to object');

    var str = '' + this;
    // To convert string to integer.
    count = +count;
    // Check NaN
    if (count != count)
      count = 0;

    if (count < 0)
      throw new RangeError('repeat count must be non-negative');

    if (count == Infinity)
      throw new RangeError('repeat count must be less than infinity');

    count = Math.floor(count);
    if (str.length == 0 || count == 0)
      return '';

    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (August 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28)
      throw new RangeError('repeat count must not overflow maximum string size');

    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while (count) {
       str += str;
       count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
  }
}

// only continue if the script is run via Windows Scripting Host
if (typeof(WScript) != 'undefined')
{
	var progArgs = WScript.Arguments;
	var canContinue = true;
	var extensionA = /\.[jJ][sS][oO][nN]$/;
	if (progArgs.length != 2)
		canContinue = false;
	else if (!extensionA.test(progArgs(0)))
		canContinue = false;
	else if (progArgs(1) == '-b')
		outMode = 0;
	else if (progArgs(1) == '-p')
		outMode = 1;
	else if (progArgs(1) == '-m')
		outMode = 2;
	else
		canContinue = false;
	if (canContinue)
	{
		try
		{
			fso = new ActiveXObject('Scripting.FileSystemObject');
			var inputPath = fso.GetFile(progArgs(0)).Path;
			ProcessFile(inputPath);
		}
		catch (e1)
		{
			WScript.echo
			(
				'Error name: '			+ e1.name
				+ '\nError message: '		+ e1.message
				+ '\nError facility code: '	+ (e1.number>>16 & 0x1FFF)
				+ '\nError error code: '	+ (e1.number & 0xFFFF)
				+ '\nError description: '	+ e1.description
			);
		}
	}
	else
	{
		WScript.Echo(usageText);
	}
}

function ProcessFile(inFilePath)
{
	WScript.Echo('Processing file: ' + inFilePath);

	// read the input file and store its contents as a string
	WScript.Echo('Reading input.');
	InputFileObject = fso.OpenTextFile(inFilePath, 1);
	var inputCodeString = InputFileObject.ReadAll();
	InputFileObject.Close();
//	WScript.Echo(inputCodeString);
	arrayOne = eval('(' + inputCodeString + ')');

	// get output file ready
	WScript.Echo('Prepping output.');
	var outFilePath = inFilePath + '.txt';
	OutputFileObject = fso.OpenTextFile(outFilePath, 2, 1, 0);

	// process the model
	WScript.Echo('Walking the tree.');
	var iModel = arrayOne[0];
	var iFile = iModel.fileName;
	var iSubs = iModel.subFiles;
	modelCount += 1;
	objectCount += 1;
	WScript.Echo(iFile);
	OutputFileObject.WriteLine(iFile);
	WalkTree(iSubs, 1);

	// finishing up
	WScript.Echo('Done.');
	OutputFileObject.Close();
	WScript.Echo(partCount + ' parts.');
	WScript.Echo(modelCount + ' models.');
	WScript.Echo(objectCount + ' objects.');
}

function WalkTree(inSubFiles, indentLevel)
{
	for (var k in inSubFiles)
	{
		var kModel = inSubFiles[k];
		var kFile = kModel.fileName;
		var kString = '  '.repeat(indentLevel) + kFile;
		var outSubFiles = [];
		var isSubModel = false;
		for (var i in arrayOne)
		{
			var iModel = arrayOne[i];
			var iFile = iModel.fileName;
			if (kFile.toLowerCase() == iFile.toLowerCase())
			{
				outSubFiles = iModel.subFiles;
				isSubModel = true;
				break;
			}
		}
		if (isSubModel == false)
		{
			if ((outMode == 1) || (outMode == 0))
			{
				WScript.Echo(kString);
				OutputFileObject.WriteLine(kString);
			}
			partCount += 1;
			objectCount += 1;
		}
		else
		{
			if ((outMode == 2) || (outMode == 0))
			{
				WScript.Echo(kString);
				OutputFileObject.WriteLine(kString);
			}
			modelCount += 1;
			objectCount += 1;
		}
		WalkTree(outSubFiles, indentLevel+1);
	}
}
